'''
Copyright 2025 The MERIT Team. All rights reserved.
'''
from tqdm import tqdm
from lmdeploy.vl import load_image
from annotator.utils import save_json_data, read_json_data, GPT4
from merit.annotate_spu import FATHER_FOLDER_PATH

def template_filter_prompt(query_instruction, pos_product_title):
    return f"""
Task: Evaluate the compliance of multimodal product search queries and their positive samples against strict quality standards. Return "yes" if compliant or "no" if non-compliant.

Input Format: A search query instruction referencing multiple products (with images and descriptions)
A positive sample product (with image and description) that should match the query criteria
Evaluation Criteria
Please assess each query-sample pair against these three critical requirements:
1. Information Completeness
All required attributes mentioned in the query MUST appear in either the text description or be visibly identifiable in the images
Check that material types, specific features, or any other attributes referenced in the query are explicitly available
2. Attribute Accuracy Match
The positive sample MUST possess all attributes specified in the query instruction
If the query requests "same [attribute] as Product 1," verify the positive sample truly matches that attribute from Product 1
If multiple reference products are used, ensure the positive sample correctly matches each referenced attribute with its corresponding product

Important Notes:
Carefully examine both images and textual descriptions when making your assessment
Be strict in your evaluation - all criteria must be met for a "yes" response

Please check the following search data

- Search query instruction: {query_instruction}
- Positive sample product:  <image>\n{pos_product_title}

Your answer is:
"""
def check_ok(response:str):
    if 'y' in response.lower():
        return True
    else:
        return False


def filter_query(query_path, product_path):
    model = GPT4(max_workers=16, qps=8)
    qv_pool = read_json_data(query_path)
    product_infos = read_json_data(product_path)
    product_map = {int(product["sku_id"]): product for product in product_infos}

    new_qv_pool = []
    
    processing_items = []
    for item in tqdm(qv_pool, desc="Preparing data"):
        q_ids = list(item["query"].keys())
        pos_id = item["pos_candidate"][0]
        if str(pos_id) in q_ids:
            continue
            
        pos_product = product_map[int(pos_id)]
        if not pos_product:
            print('no pos product')
            continue
            
        all_products_valid = True
        query_products = []
        for q_id in q_ids:
            q_product = product_map[int(q_id)]
            if not q_product:
                all_products_valid = False
                break
            query_products.append(q_product)
            
        if not all_products_valid:
            print('no cand product')
            continue
            
        processing_item = {
            "raw_item": item,
            "pos_product": pos_product,
            "query_products": query_products
        }
        processing_items.append(processing_item)
    
    def load_images_for_item(item):
        images = []
        for q_product in item["query_products"]:
            images.append(load_image(q_product["local_sku_image"]))
        images.append(load_image(item["pos_product"]["local_sku_image"]))
        return images
    
    def generate_prompt_for_item(item):
        return template_filter_prompt(
            query_instruction=item["raw_item"]["query instruction"], 
            pos_product_title=item["pos_product"]["title"]
        )
    
    def handle_result(item, response):
        if check_ok(response=response):
            new_qv_pool.append(item["raw_item"])
    
    model.process_batch(
        processing_items,
        image_loader_func=load_images_for_item,
        prompt_generator_func=generate_prompt_for_item,
        result_handler_func=handle_result,
        show_progress=True
    )
    
    print(f"Before filtering {len(qv_pool)}, After filtering {len(new_qv_pool)}, Filter ratio {len(new_qv_pool)/len(qv_pool)}")
    save_json_data(query_path.replace('-instruction.json', '-clean.json'), new_qv_pool)

if __name__ == "__main__":
    # "{FATHER_FOLDER_PATH}/retrieval_v4_0.5k-instruction.json" is the json file generated by the ./merit/annotate_query.py
    filter_query(query_path=f"{FATHER_FOLDER_PATH}/retrieval_v4_0.5k-instruction.json", 
                product_path=f'{FATHER_FOLDER_PATH}/all_products.json')
